Задача.
Необходимо реализовать Inversion of Control container (IoC).
 
С одним из них, контейнером Spring, вы уже знакомы. Предлагается реализовать свой "движок", который будет способен управлять зависимостями внутри классов в приложении аналогично Spring.
Требования к приложению:
1) Это должно быть обычное java приложение со сборщиком gradle/maven (IDEA - New Project...) без зависимостей на другие фреймворки с точкой входа в виде класса с методом public static void main(String... args)
2) Приложение должно быть способно:
                а) обнаруживать все сервисы (классы, помеченные специальной аннотацией, например @Service) в пакете, в котором лежит базовый класс и вложенных в данный пакет пакетов
                б) создавать эти сервисы и складывать созданные сервисы в общее хранилище - можно назвать его ApplicationContext
                в) корректно обрабатывать зависимость одного сервиса от другого. Предлагается поддержать три способа внедрения зависимостей - конструктор, сеттер, поле.
                Зависимостью считается поле, сеттер или аргументы конструктора, помеченные специальной аннотацией, например @Autowired.
                г) создание сервиса, внедрение зависимостей должно логгироваться в человекочитаемом виде.
 
3) Имена объектов, сервисов и аннотаций вы выбираете сами
 
Плюсом будет наличие тестов для приложения, а ещё бОльшим плюсом будет наличие тестов в директории test и написанных с использованием фреймворка junit или testng
 
 
hint: Чтобы консольное приложение не завершало работу после выполнения кода (продолжало работать как контейнер с бинами) добавьте System.in.read(); в ваш main метод. Так, поток, в котором запущено приложение будет ждать ввода символов в консоль и не будет завершать приложение.
 
Вариант 1 (Денис).
 
Реализовать аналог аннотации Scheduled из Spring
Необходимо дать возможность разработчику, использующему фреймворк, добавлять методам аннотацию, которая будет описывать периодическое выполнение метода. Метод, помеченный аннотацией должен запускатся периодически (информация о периоде запуска хранится в параметрах аннотации).
Необходимо обеспечить работу аннотации для public методов.
 
hint: Для выполнения данной задачи будет полезен java.util.concurrent.ScheduledThreadPoolExecutor
 
Пример кода, который должен работать

public class Runner { 
    public static void main(String... args) {
        //ваша логика создания контейнера IoC и обработки аннотаций
    }
}
 
@Service
class CurrentTimeService {
    public long currentMillis() {
        return System.currentTimeMillis();
    }
}
 
@Service
class LogTicker {
    private final CurrentTimeService service;
 
    @Autowired
    public LogTicker(CurrentTimeService service) {
        this.service = service;
    }
 
    @Scheduled(rate = 60, unit = TimeUnit.SECONDS)
    public void tick() {
        System.out.println(service.currentMillis());
    }
 
}
 
Вариант 2 (Ринат).
Реализовать поддержку аннотации @Timed, работающей следующим образом:
После вызова метода с данной аннотацией в лог должно быть выведено время выполнения метода. Для теста можно использовать в методе задержку в виде Thread#sleep.
 
Необходимо обеспечить работу аннотации для public методов.
 
hint: Для создания бина, в котором метод будет "донагружен" особой логикой будет полезен java.lang.reflect.Proxy#newProxyInstance
Этот прокси-бин будет расширять функциональность базового.
 
Пример кода, который должен работать
 
class Runner {
    public static void main(String... args) {
        // ваша логика создания контейнера IoC и обработки аннотаций
    }
}
 
@Service
class HeavyTaskService {
    public void processTask() throws InterruptedException {
        Thread.sleep(1000);
    }
}
 
@Service
class TaskProcessor {
 
    private final HeavyTaskService service;
 
    @Autowired
    public TaskProcessor(HeavyTaskService service) {
        this.service = service;
    }
 
    @Timed
    public void invoke() throws InterruptedException {
        service.processTask();
    }
 
}

